\documentclass[12pt,a4paper]{report}

% ============================================
% PACKAGES
% ============================================
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{physics}  % For bra-ket notation and derivatives
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{float}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{titlesec}

% ============================================
% PAGE LAYOUT
% ============================================
\geometry{
    left=1in,
    right=1in,
    top=1in,
    bottom=1in
}

% ============================================
% CODE LISTING SETTINGS
% ============================================
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=8pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={(*@}{@*)},
    morekeywords={numpy,scipy,matplotlib}
}

% ============================================
% HYPERREF SETUP
% ============================================
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue,
    pdftitle={Advanced Computational Quantum Mechanics},
    pdfauthor={},
}

% ============================================
% CUSTOM COMMANDS
% ============================================
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\hf}{\text{HF}}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\ie}{\textit{i.e.}}
\newcommand{\eg}{\textit{e.g.}}

% Operators
\newcommand{\Hop}{\hat{H}}
\newcommand{\Top}{\hat{T}}
\newcommand{\Vop}{\hat{V}}
\newcommand{\pop}{\hat{p}}
\newcommand{\rop}{\hat{r}}
\newcommand{\Fop}{\hat{F}}

% Units
\newcommand{\eV}{\text{ eV}}
\newcommand{\bohr}{a_0}
\newcommand{\Hartree}{\text{ Ha}}

% ============================================
% HEADER/FOOTER
% ============================================
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{\leftmark}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

% ============================================
% TITLE PAGE
% ============================================
\title{
    \vspace{2cm}
    \Huge\textbf{Advanced Computational Quantum Mechanics:} \\
    \LARGE\textbf{Mathematical Foundations and Numerical Implementation} \\
    \vspace{1cm}
    \Large A Comprehensive Technical Reference
    \vspace{2cm}
}
\author{}
\date{\today}

% ============================================
% DOCUMENT
% ============================================
\begin{document}

\maketitle
\tableofcontents
\newpage

% ============================================
% CHAPTER 1: FUNDAMENTALS
% ============================================
\chapter{Quantum Mechanics and Computational Quantum Mechanics}

\section{Mathematical Foundations}

\subsection{Hilbert Space and State Vectors}

The state of a quantum system is represented by a vector $\ket{\psi}$ in a complex Hilbert space $\mathcal{H}$. For a single particle in three dimensions, the wavefunction $\psi(\vb{r},t) \in L^2(\R^3)$ must belong to the space of square-integrable functions, satisfying the normalization condition:
%
\begin{equation}
\int_{-\infty}^{\infty} \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} |\psi(\vb{r},t)|^2 \, d^3\vb{r} = 1
\end{equation}

The inner product in this space is defined as:
\begin{equation}
\braket{\phi}{\psi} = \int \phi^*(\vb{r},t) \psi(\vb{r},t) \, d^3\vb{r}
\end{equation}
%
where $\phi^*$ denotes the complex conjugate. This forms a complete inner product space with norm $\|\psi\| = \sqrt{\braket{\psi}{\psi}}$.

\subsection{Fundamental Operators}

Physical observables correspond to Hermitian operators on $\mathcal{H}$. The key operators are:

\begin{itemize}
    \item \textbf{Position operator:} $\rop \psi(\vb{r}) = \vb{r} \psi(\vb{r})$
    \item \textbf{Momentum operator:} $\pop = -i\hbar\grad$
    \item \textbf{Hamiltonian operator:} $\Hop = \Top + \Vop = -\frac{\hbar^2}{2m}\laplacian + V(\vb{r})$
\end{itemize}

The Hermiticity condition $\hat{A}^\dagger = \hat{A}$ ensures real eigenvalues, corresponding to measurable physical quantities.

\subsection{Time-Independent Schrödinger Equation}

For stationary states, the time-independent Schrödinger equation (TISE) determines the energy eigenvalues and eigenfunctions:
%
\begin{equation}
\Hop \phi(\vb{r}) = E \phi(\vb{r})
\label{eq:tise}
\end{equation}

Explicitly for a single particle:
\begin{equation}
\left[-\frac{\hbar^2}{2m}\laplacian + V(\vb{r})\right] \phi(\vb{r}) = E \phi(\vb{r})
\end{equation}

\section{Analytical Solutions: Hydrogen Atom}

The hydrogen atom provides one of the few exactly solvable quantum systems. In spherical coordinates $(r,\theta,\phi)$, the TISE becomes:
%
\begin{equation}
\left[-\frac{\hbar^2}{2\mu}\left(\frac{1}{r^2}\pdv{r}\left(r^2\pdv{r}\right) + \frac{\hat{L}^2}{\hbar^2 r^2}\right) - \frac{e^2}{4\pi\epsilon_0 r}\right]\psi = E\psi
\end{equation}
%
where $\mu = \frac{m_e m_p}{m_e + m_p} \approx m_e$ is the reduced mass. Separation of variables $\psi(r,\theta,\phi) = R(r)Y_\ell^m(\theta,\phi)$ yields:

\paragraph{Radial equation:}
\begin{equation}
\left[-\frac{\hbar^2}{2\mu r^2}\dv{r}\left(r^2\dv{R}{r}\right) + \frac{\hbar^2\ell(\ell+1)}{2\mu r^2} - \frac{e^2}{4\pi\epsilon_0 r}\right]R(r) = ER(r)
\end{equation}

\paragraph{Energy eigenvalues:}
\begin{equation}
E_n = -\frac{\mu e^4}{32\pi^2\epsilon_0^2\hbar^2 n^2} \approx -\frac{13.6\eV}{n^2}, \quad n = 1,2,3,\ldots
\end{equation}

\paragraph{Bohr radius:}
\begin{equation}
\bohr = \frac{4\pi\epsilon_0\hbar^2}{\mu e^2} \approx 0.529 \text{ Å}
\end{equation}

First three radial wavefunctions:
\begin{align}
R_{10}(r) &= 2\left(\frac{Z}{\bohr}\right)^{3/2} \exp\left(-\frac{Zr}{\bohr}\right) \\
R_{20}(r) &= \frac{1}{2\sqrt{2}}\left(\frac{Z}{\bohr}\right)^{3/2} \left(2 - \frac{Zr}{\bohr}\right) \exp\left(-\frac{Zr}{2\bohr}\right) \\
R_{21}(r) &= \frac{1}{2\sqrt{6}}\left(\frac{Z}{\bohr}\right)^{3/2} \frac{Zr}{\bohr} \exp\left(-\frac{Zr}{2\bohr}\right)
\end{align}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 1.1: Radial probability distributions $4\pi r^2|R_{n\ell}(r)|^2$ for $n=1,2,3$ orbitals of hydrogen, showing nodes and peak positions]}}
\caption{Hydrogen atom radial probability distributions}
\label{fig:hydrogen_radial}
\end{figure}

\section{The Many-Body Problem}

For $N$ electrons interacting with $M$ nuclei, the full non-relativistic Hamiltonian is:
%
\begin{equation}
\Hop = \Top_e + \Top_n + \Vop_{en} + \Vop_{ee} + \Vop_{nn}
\end{equation}
%
where:
\begin{align}
\Top_e &= -\sum_{i=1}^N \frac{\hbar^2}{2m_e}\nabla_i^2 \quad \text{(electron kinetic)} \\
\Top_n &= -\sum_{a=1}^M \frac{\hbar^2}{2M_a}\nabla_a^2 \quad \text{(nuclear kinetic)} \\
\Vop_{en} &= -\sum_{i=1}^N \sum_{a=1}^M \frac{Z_a e^2}{4\pi\epsilon_0|\vb{r}_i - \vb{R}_a|} \quad \text{(electron-nuclear)} \\
\Vop_{ee} &= \sum_{i<j} \frac{e^2}{4\pi\epsilon_0|\vb{r}_i - \vb{r}_j|} \quad \text{(electron-electron)} \\
\Vop_{nn} &= \sum_{a<b} \frac{Z_a Z_b e^2}{4\pi\epsilon_0|\vb{R}_a - \vb{R}_b|} \quad \text{(nuclear-nuclear)}
\end{align}

\paragraph{Computational scaling:} The wavefunction $\Psi(\vb{r}_1,\ldots,\vb{r}_N,\vb{R}_1,\ldots,\vb{R}_M)$ depends on $3(N+M)$ coordinates. Discretizing each dimension with $M$ grid points gives $M^{3(N+M)}$ total points:

\begin{itemize}
    \item H$_2$ (2 electrons, 2 nuclei): $M^{12}$ points
    \item H$_2$O (10 electrons, 3 nuclei): $M^{39}$ points
    \item C$_6$H$_6$ (42 electrons, 12 nuclei): $M^{162}$ points
\end{itemize}

For $M=100$, H$_2$O requires $10^{39}$ points --- utterly intractable.

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 1.2: Log-log plot showing exponential growth of required grid points vs number of electrons for $M=50, 100, 200$]}}
\caption{Exponential scaling of direct grid method}
\label{fig:grid_scaling}
\end{figure}

\section{Born-Oppenheimer Approximation}

Nuclear masses greatly exceed electron mass ($m_e/M_p \approx 1/1836$), allowing separation:
%
\begin{equation}
\Psi_{\text{total}}(\vb{r},\vb{R}) \approx \psi_e(\vb{r};\vb{R}) \chi_n(\vb{R})
\end{equation}

The electronic Hamiltonian at fixed nuclear positions $\vb{R}$:
\begin{equation}
\Hop_e \psi_e(\vb{r};\vb{R}) = E_e(\vb{R}) \psi_e(\vb{r};\vb{R})
\end{equation}
where $E_e(\vb{R})$ forms the potential energy surface for nuclear motion.

\textbf{Error magnitude:} $\sim (m_e/M)^{1/4} \approx 10^{-3}$, increasing near conical intersections.

\section{Density Functional Theory}

\subsection{Hohenberg-Kohn Theorems}

\paragraph{Theorem 1 (Existence):} The ground state energy is a unique functional of electron density:
\begin{equation}
E_0 = E[n_0(\vb{r})] = \int V_{\text{ext}}(\vb{r}) n_0(\vb{r}) \, d\vb{r} + F[n_0(\vb{r})]
\end{equation}
where $F[n] = T[n] + V_{ee}[n]$ is a universal functional (independent of $V_{\text{ext}}$).

\paragraph{Theorem 2 (Variational Principle):} For any trial density $\tilde{n}(\vb{r})$ with $\int \tilde{n}(\vb{r})\,d\vb{r} = N$:
\begin{equation}
E[\tilde{n}] \geq E[n_0], \quad \text{with equality iff } \tilde{n} = n_0
\end{equation}

\subsection{Kohn-Sham Equations}

Map the interacting system to a non-interacting one with the same density:
%
\begin{equation}
\left[-\frac{\hbar^2}{2m_e}\laplacian + V_{\text{eff}}[n](\vb{r})\right]\phi_i(\vb{r}) = \varepsilon_i \phi_i(\vb{r})
\end{equation}
%
\begin{equation}
V_{\text{eff}}[n](\vb{r}) = V_{\text{ext}}(\vb{r}) + \int \frac{e^2 n(\vb{r}')}{4\pi\epsilon_0|\vb{r}-\vb{r}'|}\,d\vb{r}' + V_{xc}[n](\vb{r})
\end{equation}
%
\begin{equation}
n(\vb{r}) = \sum_{i=1}^N |\phi_i(\vb{r})|^2
\end{equation}

The exchange-correlation potential $V_{xc} = \delta E_{xc}/\delta n(\vb{r})$ contains all many-body effects.

\paragraph{Common approximations:}

\textbf{Local Density Approximation (LDA):}
\begin{equation}
E_{xc}^{\text{LDA}}[n] = \int n(\vb{r}) \varepsilon_{xc}(n(\vb{r})) \, d\vb{r}
\end{equation}

\textbf{Generalized Gradient Approximation (GGA) --- PBE functional:}
\begin{equation}
E_{xc}^{\text{PBE}}[n] = \int n(\vb{r}) \varepsilon_{xc}(n(\vb{r}), |\grad n(\vb{r})|) \, d\vb{r}
\end{equation}

\textbf{Hybrid functionals (B3LYP):}
\begin{equation}
E_{xc}^{\text{B3LYP}} = 0.8E_x^{\text{LDA}} + 0.2E_x^{\text{HF}} + 0.72\Delta E_x^{\text{B88}} + 0.19E_c^{\text{VWN}} + 0.81E_c^{\text{LYP}}
\end{equation}

\textbf{Computational scaling:} DFT-KS scales as $\mathcal{O}(N^3)$ with system size $N$ (matrix diagonalization), compared to $\mathcal{O}(N!)$ for exact methods.

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 1.3: Computational cost comparison (log-scale) for Full CI, CCSD, MP2, DFT, Tight-Binding vs system size $N$]}}
\caption{Scaling of quantum mechanical methods}
\label{fig:method_scaling}
\end{figure}

% ============================================
% CHAPTER 2: PROGRAMMING
% ============================================
\chapter{Programming and Algorithmic Analysis}

\section{Computational Complexity}

Key computational bottlenecks in quantum simulations:

\begin{itemize}
    \item \textbf{Matrix diagonalization:} $\mathcal{O}(N^3)$ for dense $N \times N$ matrices
    \item \textbf{Two-electron integrals:} $\mathcal{O}(N^4)$ for $N$ basis functions
    \item \textbf{SCF iterations:} 10--100 cycles typically required
    \item \textbf{Sparse linear solvers:} $\mathcal{O}(N^{1.5})$ for sparse Hamiltonians
\end{itemize}

\section{Python Scientific Computing Stack}

\subsection{NumPy --- Numerical Linear Algebra}

Core functions:
\begin{itemize}
    \item \texttt{np.linalg.eigh(A)}: Hermitian eigendecomposition, $\mathcal{O}(N^3)$
    \item \texttt{np.einsum('ij,jk->ik', A, B)}: Efficient tensor contractions
    \item \texttt{np.linalg.lstsq(A, b)}: Least-squares solutions
    \item \texttt{np.fft}: Fast Fourier Transform, $\mathcal{O}(N \log N)$
\end{itemize}

\subsection{SciPy --- Advanced Algorithms}

\begin{itemize}
    \item \texttt{scipy.sparse}: COO, CSR, CSC formats for sparse matrices
    \item \texttt{scipy.sparse.linalg.eigs()}: Iterative eigensolvers (Lanczos/Arnoldi)
    \item \texttt{scipy.integrate.odeint()}: Stiff ODE solver (for TDSE)
    \item \texttt{scipy.optimize}: BFGS, conjugate gradient for geometry optimization
\end{itemize}

\subsection{PySCF --- Production Quantum Chemistry}

\begin{itemize}
    \item Hartree-Fock: \texttt{pyscf.scf.RHF()}, \texttt{pyscf.scf.UHF()}
    \item Post-HF: MP2, CCSD, CCSD(T), Full CI
    \item DFT: LDA, PBE, B3LYP, $\omega$B97X-D functionals
    \item TDDFT: Linear response excited states
\end{itemize}

\section{Parallel Computing}

\subsection{Shared Memory Parallelism (OpenMP)}

BLAS libraries (MKL, OpenBLAS) automatically parallelize matrix operations. Speedup:
\begin{equation}
S(p) = \frac{T(1)}{T(p)} \approx \frac{p}{1 + (p-1)f}
\end{equation}
where $f$ is the serial fraction (Amdahl's law).

\subsection{Distributed Memory (MPI)}

For multi-node clusters, use \texttt{mpi4py} for Python:
\begin{itemize}
    \item Distribute Hamiltonian matrix blocks across processes
    \item Local computation of matrix elements
    \item \texttt{MPI\_Allgather} for global communication
\end{itemize}

\subsection{GPU Acceleration}

Modern GPUs provide 10--100$\times$ speedup for dense linear algebra:
\begin{itemize}
    \item CuPy: NumPy API for NVIDIA CUDA
    \item TensorFlow/PyTorch: Automatic differentiation
    \item Typical speedup: 20--50$\times$ for $N>1000$ matrix operations
\end{itemize}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 2.1: Benchmark plot showing CPU vs GPU vs Multi-CPU (MPI) execution time for matrix diagonalization, $N=100$ to $10000$]}}
\caption{Performance comparison for matrix operations}
\label{fig:cpu_gpu_benchmark}
\end{figure}

% ============================================
% CHAPTER 3: QUANTUM DYNAMICS
% ============================================
\chapter{Computational Quantum Dynamics}

\section{Time-Dependent Schrödinger Equation}

The TDSE governs quantum time evolution:
\begin{equation}
i\hbar \pdv{t}\ket{\psi(t)} = \Hop(t)\ket{\psi(t)}
\end{equation}

Formal solution (time-ordered exponential):
\begin{equation}
\ket{\psi(t)} = \mathcal{T} \exp\left(-\frac{i}{\hbar}\int_{t_0}^t \Hop(t')\,dt'\right)\ket{\psi(t_0)}
\end{equation}

For time-independent $\Hop$:
\begin{equation}
\hat{U}(t,t_0) = \exp\left(-\frac{i\Hop(t-t_0)}{\hbar}\right)
\end{equation}

\section{Split-Operator Method}

For $\Hop = \Top + \Vop$, use Trotter-Suzuki decomposition:
\begin{equation}
\exp\left(-\frac{i\Hop\Delta t}{\hbar}\right) = \exp\left(-\frac{i\Top\Delta t}{2\hbar}\right)\exp\left(-\frac{i\Vop\Delta t}{\hbar}\right)\exp\left(-\frac{i\Top\Delta t}{2\hbar}\right) + \mathcal{O}(\Delta t^3)
\end{equation}

\paragraph{Algorithm:}
\begin{enumerate}
    \item $\tilde{\psi}(\vb{p}) = \text{FFT}[\psi(\vb{x})]$
    \item $\tilde{\psi}'(\vb{p}) = \exp\left(-\frac{ip^2\Delta t}{4m\hbar}\right) \tilde{\psi}(\vb{p})$
    \item $\psi'(\vb{x}) = \text{IFFT}[\tilde{\psi}'(\vb{p})]$
    \item $\psi''(\vb{x}) = \exp\left(-\frac{iV(\vb{x})\Delta t}{\hbar}\right) \psi'(\vb{x})$
    \item Repeat steps 1--2 once more
\end{enumerate}

\paragraph{Properties:}
\begin{itemize}
    \item Unitary (norm-preserving): $\|\psi(t)\| = \|\psi(0)\|$
    \item Computational cost: $\mathcal{O}(N \log N)$ per timestep
    \item Error: $\mathcal{O}(\Delta t^3)$ local, $\mathcal{O}(\Delta t^2)$ global
\end{itemize}

\section{Runge-Kutta Methods}

\subsection{Fourth-Order Runge-Kutta (RK4)}

Rewrite TDSE as: $\dv{\psi}{t} = f(\psi,t) = -\frac{i\Hop(t)\psi}{\hbar}$

\begin{align}
k_1 &= \Delta t \, f(\psi_n, t_n) \\
k_2 &= \Delta t \, f(\psi_n + k_1/2, t_n + \Delta t/2) \\
k_3 &= \Delta t \, f(\psi_n + k_2/2, t_n + \Delta t/2) \\
k_4 &= \Delta t \, f(\psi_n + k_3, t_n + \Delta t) \\
\psi_{n+1} &= \psi_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\end{align}

\textbf{Accuracy:} $\mathcal{O}(\Delta t^4)$ global error

\textbf{Limitation:} Non-unitary --- norm can drift, requires renormalization

\section{Chebyshev Polynomial Expansion}

Expand propagator using Chebyshev polynomials $T_n(x)$:
\begin{equation}
\exp\left(-\frac{i\Hop t}{\hbar}\right) = \sum_{n=0}^{\infty} a_n(t) T_n\left(\frac{\Hop - c}{\Delta}\right)
\end{equation}
where $c = (E_{\max} + E_{\min})/2$, $\Delta = (E_{\max} - E_{\min})/2$ rescale spectrum to $[-1,1]$.

Coefficients:
\begin{equation}
a_n(t) = (2-\delta_{n0})(-i)^n \exp\left(-\frac{ict}{\hbar}\right) J_n\left(\frac{\Delta t}{\hbar}\right)
\end{equation}
where $J_n$ is the Bessel function of the first kind.

\textbf{Recurrence:} $T_0(x)=1$, $T_1(x)=x$, $T_{n+1}(x)=2xT_n(x)-T_{n-1}(x)$

\paragraph{Advantages:}
\begin{itemize}
    \item Spectral accuracy: exponential convergence with order $n$
    \item Unitary to machine precision
    \item Only requires $\Hop\ket{\psi}$ (no diagonalization)
\end{itemize}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 3.1: Norm conservation comparison: Split-Operator, RK4, Chebyshev over 1000 steps showing RK4 drift]}}
\caption{Comparison of norm conservation for different propagators}
\label{fig:norm_conservation}
\end{figure}

% ============================================
% CHAPTER 4: CODE IMPLEMENTATION
% ============================================
\chapter{Implementation: Detailed Code Examples}

\section{Time-Independent Schrödinger Equation Solver}

\subsection{Problem: 1D Quantum Harmonic Oscillator}

TISE in dimensionless units ($\hbar=m=\omega=1$):
\begin{equation}
\left[-\frac{1}{2}\dv[2]{x} + \frac{x^2}{2}\right]\phi(x) = E\phi(x)
\end{equation}

\textbf{Analytical:} $E_n = n + 1/2$, $\phi_n(x) = \frac{1}{\sqrt{2^n n! \sqrt{\pi}}} H_n(x) e^{-x^2/2}$

\subsection{Finite Difference Discretization}

Grid: $x_j = -L + j\Delta x$, $j=0,1,\ldots,N-1$, $\Delta x = 2L/(N-1)$

Central difference ($\mathcal{O}(\Delta x^2)$):
\begin{equation}
\left.\dv[2]{\phi}{x}\right|_j \approx \frac{\phi_{j+1} - 2\phi_j + \phi_{j-1}}{\Delta x^2}
\end{equation}

Hamiltonian matrix (tridiagonal):
\begin{equation}
H_{ij} = \delta_{ij}\left(\frac{1}{\Delta x^2} + \frac{x_i^2}{2}\right) - \frac{\delta_{i,j\pm 1}}{2\Delta x^2}
\end{equation}

\subsection{Complete Python Implementation}

\begin{lstlisting}[caption={1D Harmonic Oscillator TISE Solver}]
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

# ============================================
# 1D Harmonic Oscillator TISE Solver
# ============================================

def solve_harmonic_oscillator_1d(N=500, L=10, n_states=5):
    """
    Solve 1D harmonic oscillator using finite difference method
    
    Parameters:
    -----------
    N : int
        Number of grid points
    L : float
        Half-length of domain [-L, L]
    n_states : int
        Number of lowest eigenstates to compute
        
    Returns:
    --------
    x : ndarray
        Spatial grid
    energies : ndarray
        Energy eigenvalues
    wavefunctions : ndarray
        Normalized eigenfunctions
    """
    
    # Create spatial grid
    x = np.linspace(-L, L, N)
    dx = x[1] - x[0]
    
    # Construct Hamiltonian matrix (tridiagonal)
    # H = T + V where T = -1/(2dx^2) (*@$\times$@*) second derivative
    #                 V = diag(x^2/2)
    
    # Kinetic energy matrix
    T_diag = np.ones(N) / dx**2
    T_offdiag = -np.ones(N-1) / (2*dx**2)
    
    # Potential energy matrix
    V = 0.5 * x**2
    
    # Full Hamiltonian
    H = (np.diag(T_diag + V) + 
         np.diag(T_offdiag, k=1) + 
         np.diag(T_offdiag, k=-1))
    
    # Solve eigenvalue problem (*@$H\phi = E\phi$@*)
    energies, wavefunctions = eigh(H)
    
    # Extract requested states
    energies = energies[:n_states]
    wavefunctions = wavefunctions[:, :n_states]
    
    # Normalize wavefunctions
    for i in range(n_states):
        norm = np.sqrt(np.trapz(np.abs(wavefunctions[:, i])**2, x))
        wavefunctions[:, i] /= norm
        
        # Phase convention: positive at center
        center_idx = N // 2
        if wavefunctions[center_idx, i] < 0:
            wavefunctions[:, i] *= -1
    
    return x, energies, wavefunctions


def analytical_harmonic_oscillator(x, n):
    """
    Analytical solution: (*@$\phi_n(x) = \frac{1}{\sqrt{2^n n! \sqrt{\pi}}} H_n(x) e^{-x^2/2}$@*)
    """
    from scipy.special import hermite, factorial
    
    N_n = 1.0 / np.sqrt(2**n * factorial(n) * np.sqrt(np.pi))
    H_n = hermite(n)
    phi_n = N_n * H_n(x) * np.exp(-x**2 / 2)
    
    return phi_n


# ============================================
# Main execution
# ============================================

if __name__ == "__main__":
    print("="*60)
    print("1D Harmonic Oscillator: Numerical vs Analytical")
    print("="*60)
    
    # Solve numerically
    x, E_num, psi_num = solve_harmonic_oscillator_1d(N=500, L=10, n_states=5)
    
    # Analytical energies
    E_analytical = np.array([n + 0.5 for n in range(5)])
    
    # Print comparison
    print("\nEnergy Eigenvalues:")
    print("-" * 70)
    print(f"{'n':>3} | {'E_numerical':>15} | {'E_analytical':>15} | {'Rel. Error':>12}")
    print("-" * 70)
    
    for n in range(5):
        rel_error = np.abs(E_num[n] - E_analytical[n]) / E_analytical[n]
        print(f"{n:3d} | {E_num[n]:15.10f} | {E_analytical[n]:15.10f} | {rel_error:12.2e}")
\end{lstlisting}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.1: Plot showing numerical vs analytical wavefunctions $\phi_0, \phi_1, \phi_2$ overlaid]}}
\caption{Comparison of numerical and analytical solutions}
\label{fig:wavefunction_comparison}
\end{figure}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.2: Log-log plot of energy error vs grid spacing $\Delta x$, demonstrating $\mathcal{O}(\Delta x^2)$ convergence]}}
\caption{Convergence analysis of finite difference method}
\label{fig:convergence_analysis}
\end{figure}

\subsection{Convergence Analysis and Error Scaling}

The finite difference approximation introduces truncation error:
\begin{equation}
\varepsilon_{\text{trunc}} = |E_{\text{numerical}} - E_{\text{exact}}| = C \times \Delta x^2 + \mathcal{O}(\Delta x^4)
\end{equation}

Empirical fitting shows $C \approx 0.01$ for the ground state. Doubling grid resolution ($N \to 2N$, $\Delta x \to \Delta x/2$) reduces error by factor of 4, confirming second-order convergence.

For $n$-th excited state, error magnitude increases as:
\begin{equation}
\varepsilon_n \approx C_n \times \Delta x^2, \quad \text{where } C_n \approx C_0 \times (n+1)^2
\end{equation}

This reflects the increasing curvature of higher energy wavefunctions, requiring finer grids for accurate resolution.

\section{Time-Dependent Schrödinger Equation: Split-Operator Method}

\subsection{Problem: Gaussian Wave Packet in Harmonic Potential}

Initial state (Gaussian wave packet):
\begin{equation}
\psi(x,0) = (2\pi\sigma^2)^{-1/4} \exp\left(-\frac{(x-x_0)^2}{4\sigma^2}\right) \exp\left(\frac{ip_0 x}{\hbar}\right)
\end{equation}

Time evolution under $V(x) = x^2/2$ (dimensionless units).

\textbf{Physical interpretation:} Wave packet oscillates in harmonic potential with angular frequency $\omega = 1$.

\subsection{Split-Operator Algorithm Implementation}

\begin{lstlisting}[caption={Split-Operator Propagator for TDSE},label={lst:split_operator}]
import numpy as np

def split_operator_propagator(psi, V, dt, dx):
    """
    Single time step using split-operator method
    
    (*@$\exp(-i\hat{H}\Delta t/\hbar) \approx \exp(-i\hat{T}\Delta t/2\hbar) \exp(-i\hat{V}\Delta t/\hbar) \exp(-i\hat{T}\Delta t/2\hbar)$@*)
    """
    N = len(psi)
    L = N * dx
    k = 2 * np.pi * np.fft.fftfreq(N, dx)
    
    # Kinetic energy in momentum space
    T_k = 0.5 * k**2
    
    # Step 1: Half-step kinetic propagation
    psi_tilde = np.fft.fft(psi)
    psi_tilde *= np.exp(-1j * T_k * dt / 2)
    
    # Step 2: Transform to position space
    psi = np.fft.ifft(psi_tilde)
    
    # Step 3: Full-step potential propagation
    psi *= np.exp(-1j * V * dt)
    
    # Step 4: Half-step kinetic (repeat)
    psi_tilde = np.fft.fft(psi)
    psi_tilde *= np.exp(-1j * T_k * dt / 2)
    psi = np.fft.ifft(psi_tilde)
    
    return psi


def simulate_wave_packet(N=1024, L=20, T_final=10, dt=0.01,
                         x0=0, p0=2, sigma=1):
    """Simulate Gaussian wave packet in harmonic oscillator"""
    
    x = np.linspace(-L, L, N)
    dx = x[1] - x[0]
    V = 0.5 * x**2
    
    # Initial Gaussian wave packet
    norm = (2 * np.pi * sigma**2)**(-0.25)
    psi = norm * np.exp(-(x - x0)**2 / (4 * sigma**2) + 1j * p0 * x)
    psi /= np.sqrt(np.trapz(np.abs(psi)**2, x))
    
    # Time evolution
    n_steps = int(T_final / dt)
    psi_t = [psi.copy()]
    times = [0]
    
    for step in range(1, n_steps + 1):
        psi = split_operator_propagator(psi, V, dt, dx)
        
        if step % (n_steps // 100) == 0:
            psi_t.append(psi.copy())
            times.append(step * dt)
    
    return x, psi_t, np.array(times)
\end{lstlisting}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.3: Animation frames showing $|\psi(x,t)|^2$ evolution at $t=0, \pi/2, \pi, 3\pi/2, 2\pi$]}}
\caption{Wave packet evolution in harmonic potential}
\label{fig:wavepacket_evolution}
\end{figure}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.4: Plot of $\langle x\rangle(t)$ vs $t$ showing oscillatory behavior, numerical (solid) vs analytical (dashed)]}}
\caption{Expectation value dynamics}
\label{fig:expectation_dynamics}
\end{figure}

\subsection{Numerical Stability and Error Analysis}

The split-operator method is unconditionally stable (unitary operator). However, accuracy depends on time step:

\begin{itemize}
    \item \textbf{Local error:} $\mathcal{O}(\Delta t^3)$ per step (from Trotter decomposition)
    \item \textbf{Global error:} $\mathcal{O}(\Delta t^2)$ over time $T$ (accumulated from $T/\Delta t$ steps)
\end{itemize}

For the harmonic oscillator, total energy should be conserved. Empirical energy error:
\begin{equation}
\frac{\Delta E}{E} \approx 10^{-6} \text{ for } \Delta t = 0.01, \text{ improving as } \Delta t^2
\end{equation}

\section{Hartree-Fock Self-Consistent Field Method}

\subsection{Theoretical Foundation}

The Hartree-Fock method approximates the $N$-electron wavefunction as a single Slater determinant:
\begin{equation}
\Psi(\vb{r}_1,\ldots,\vb{r}_N) = \frac{1}{\sqrt{N!}} \det[\phi_i(\vb{r}_j)]
\end{equation}

Energy functional:
\begin{equation}
E[\{\phi_i\}] = \sum_i h_{ii} + \frac{1}{2}\sum_{ij} (J_{ij} - K_{ij})
\end{equation}
where:
\begin{align}
h_{ij} &= \braket{\phi_i | -\frac{\hbar^2}{2m}\laplacian + V_{\text{ext}} | \phi_j} \\
J_{ij} &= \iint |\phi_i(\vb{r}_1)|^2 \frac{e^2}{|\vb{r}_1-\vb{r}_2|} |\phi_j(\vb{r}_2)|^2 \, d\vb{r}_1 d\vb{r}_2 \\
K_{ij} &= \iint \phi_i^*(\vb{r}_1)\phi_j(\vb{r}_1) \frac{e^2}{|\vb{r}_1-\vb{r}_2|} \phi_j^*(\vb{r}_2)\phi_i(\vb{r}_2) \, d\vb{r}_1 d\vb{r}_2
\end{align}

The Hartree-Fock equations (Fock equations):
\begin{equation}
\Fop \phi_i = \varepsilon_i \phi_i
\end{equation}
where the Fock operator:
\begin{equation}
\Fop = \hat{h} + \sum_j (\hat{J}_j - \hat{K}_j)
\end{equation}

\subsection{Implementation: Helium Atom}

\begin{lstlisting}[caption={Hartree-Fock for Helium Atom},label={lst:hartree_fock}]
import numpy as np
from scipy.special import genlaguerre, factorial
from scipy.integrate import trapz
from scipy.linalg import eigh

class HeliumHartreeFock:
    """
    Restricted Hartree-Fock for Helium atom (2 electrons)
    Both electrons occupy same spatial orbital (1s) with opposite spins
    """
    
    def __init__(self, r_max=20, n_points=2000):
        self.r = np.linspace(1e-6, r_max, n_points)
        self.dr = self.r[1] - self.r[0]
        self.Z = 2  # Nuclear charge for He
        
        # Initial guess: hydrogen-like 1s orbital
        self.phi = self.hydrogen_radial(n=1, l=0)
        self.normalize_orbital()
        
    def hydrogen_radial(self, n, l):
        """Hydrogen-like radial wavefunction"""
        a0 = 1  # Atomic units
        rho = 2 * self.Z * self.r / (n * a0)
        N = np.sqrt((2*self.Z/(n*a0))**3 * factorial(n-l-1) / (2*n*factorial(n+l)))
        L = genlaguerre(n-l-1, 2*l+1)
        return N * rho**l * np.exp(-rho/2) * L(rho)
        
    def normalize_orbital(self):
        """Normalize: (*@$\int |\phi(r)|^2 r^2 dr = 1$@*)"""
        norm = np.sqrt(trapz(self.phi**2 * self.r**2, self.r))
        self.phi /= norm
        
    def compute_coulomb_potential(self):
        """Compute Coulomb potential from electron density"""
        rho = self.phi**2
        J = np.zeros_like(self.r)
        
        for i, r_val in enumerate(self.r):
            integrand_less = rho[:i+1] * self.r[:i+1] / r_val if i > 0 else [0]
            integrand_greater = rho[i:] * self.r[i:]
            
            J[i] = (trapz(integrand_less * self.r[:i+1], self.r[:i+1]) +
                    trapz(integrand_greater, self.r[i:]))
        
        return J
        
    def solve_fock_equation(self, max_iter=100, tol=1e-8):
        """Self-consistent field iteration"""
        energy_history = []
        
        for iteration in range(max_iter):
            # Kinetic energy
            T_phi = -0.5 * np.gradient(np.gradient(self.phi, self.dr), self.dr)
            
            # Nuclear attraction
            V_nuc_phi = -self.Z / self.r * self.phi
            
            # Coulomb and exchange potentials
            J = self.compute_coulomb_potential()
            K = J / 2  # For He RHF
            
            F_phi = T_phi + V_nuc_phi + J * self.phi - K * self.phi
            
            # Orbital energy
            epsilon = trapz(self.phi * F_phi * self.r**2, self.r)
            
            # Update orbital (simplified)
            phi_new = F_phi / epsilon
            self.phi = phi_new
            self.normalize_orbital()
            
            # Total energy
            h_phi = T_phi + V_nuc_phi
            h_exp = trapz(self.phi * h_phi * self.r**2, self.r)
            E_total = 2 * h_exp + trapz(self.phi * (J - K) * self.phi * self.r**2, self.r)
            
            energy_history.append(E_total)
            
            if iteration > 0 and abs(E_total - energy_history[-2]) < tol:
                print(f"Converged in {iteration+1} iterations")
                print(f"Final energy: {E_total:.8f} Ha")
                return E_total, energy_history
            
            if iteration % 10 == 0:
                print(f"Iteration {iteration}: E = {E_total:.8f} Ha")
        
        return E_total, energy_history
\end{lstlisting}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.5: HF energy convergence vs iteration number, showing exponential approach]}}
\caption{Hartree-Fock SCF convergence for helium}
\label{fig:hf_convergence}
\end{figure}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 4.6: Comparison of HF radial orbital $\phi(r)$ vs improved wavefunction]}}
\caption{HF orbital comparison}
\label{fig:hf_orbital}
\end{figure}

\subsection{Analysis of HF Approximation}

The HF method captures $\sim$98--99\% of total energy for light atoms. The missing energy (correlation energy) arises from:

\begin{itemize}
    \item Mean-field approximation: electrons interact with average field, not instantaneously
    \item Single determinant: true wavefunction requires linear combination of determinants
    \item Exchange only for same-spin electrons: opposite-spin correlation neglected
\end{itemize}

For Helium:
\begin{equation}
E_{\text{correlation}} = E_{\text{exact}} - E_{\text{HF}} \approx -2.9037 - (-2.86) \approx -0.04\Hartree
\end{equation}

This represents $\sim$1.4\% of total binding energy.

% ============================================
% CHAPTER 5: ADVANCED TOPICS
% ============================================
\chapter{Advanced Topics and Extensions}

\section{Basis Set Selection and Convergence}

Gaussian-type orbitals (GTOs) are standard in quantum chemistry:
\begin{equation}
\chi_{\text{GTO}}(\vb{r}) = N x^l y^m z^n \exp(-\alpha r^2)
\end{equation}

Common basis sets:
\begin{itemize}
    \item \textbf{STO-3G:} Minimal basis, 3 GTOs per Slater-type orbital
    \item \textbf{6-31G:} Split-valence, core: 6 GTOs, valence: 3+1 GTOs
    \item \textbf{cc-pVDZ, cc-pVTZ, cc-pVQZ:} Correlation-consistent, systematically improvable
\end{itemize}

Energy convergence with basis size $n$:
\begin{equation}
E(n) = E_{\text{CBS}} + \frac{A}{n^3} + \frac{B}{n^5}
\end{equation}
where $E_{\text{CBS}}$ is the complete basis set limit.

\section{Post-Hartree-Fock Methods}

Methods to recover electron correlation:

\begin{itemize}
    \item \textbf{MP2 (2nd-order Møller-Plesset):} $\mathcal{O}(N^5)$ scaling
    \item \textbf{CCSD (Coupled-Cluster Singles and Doubles):} $\mathcal{O}(N^6)$ scaling, ``gold standard''
    \item \textbf{CCSD(T):} $\mathcal{O}(N^7)$ scaling, includes perturbative triples
    \item \textbf{Full CI:} Exact within basis, $\mathcal{O}(N!)$ scaling --- intractable for $N>20$
\end{itemize}

\section{Density Functional Theory in Practice}

DFT workflow:
\begin{enumerate}
    \item Choose functional (LDA, GGA, hybrid, meta-GGA)
    \item Select basis set (plane waves for solids, GTOs for molecules)
    \item Set convergence criteria ($10^{-6}$\Hartree for energy, $10^{-4}$ for forces)
    \item Initialize density (atomic superposition or random)
    \item SCF iteration until convergence
    \item Analyze results (charge density, DOS, band structure)
\end{enumerate}

\begin{figure}[H]
\centering
\textcolor{red}{\textit{[INSERT FIGURE 5.1: Flowchart showing DFT SCF cycle: Initial guess $\to$ Build Hamiltonian $\to$ Diagonalize $\to$ Update density $\to$ Check convergence]}}
\caption{DFT self-consistent field cycle}
\label{fig:dft_scf_cycle}
\end{figure}

\section{Future Directions}

Emerging methods in computational quantum mechanics:

\begin{itemize}
    \item Machine learning potentials: Neural networks trained on \textit{ab initio} data
    \item Quantum computing: Variational Quantum Eigensolver (VQE) for molecules
    \item Linear-scaling DFT: $\mathcal{O}(N)$ methods for large systems (1000+ atoms)
    \item Time-dependent DFT: Excited states and spectroscopy
    \item Path integral molecular dynamics: Quantum nuclear effects
\end{itemize}

\section{Method Comparison Summary}

\begin{table}[H]
\centering
\caption{Comprehensive comparison of quantum mechanical methods}
\label{tab:method_comparison}
\begin{tabular}{@{}lccl@{}}
\toprule
Method & Scaling & Accuracy & Applications \\ \midrule
Hartree-Fock & $\mathcal{O}(N^3)$ & 98--99\% $E$ & Initial guess, small molecules \\
MP2 & $\mathcal{O}(N^5)$ & 99.5\% $E$ & Medium molecules, weak corr. \\
CCSD & $\mathcal{O}(N^6)$ & 99.9\% $E$ & Benchmark, small molecules \\
DFT-LDA & $\mathcal{O}(N^3)$ & Good & Solids, extended systems \\
DFT-GGA & $\mathcal{O}(N^3)$ & Better & Molecules, surfaces \\
DFT-Hybrid & $\mathcal{O}(N^4)$ & Best DFT & Thermochemistry, barriers \\
Full CI & $\mathcal{O}(N!)$ & Exact & Tiny systems only ($N<20$) \\ \bottomrule
\end{tabular}
\end{table}

$E$ = total electronic energy relative to exact solution within basis set

% ============================================
% APPENDICES
% ============================================
\appendix

\chapter{Useful Constants and Conversion Factors}

Fundamental constants in atomic units ($\hbar = m_e = e = 4\pi\epsilon_0 = 1$):

\begin{itemize}
    \item Energy unit (Hartree): $E_h = 27.211\eV = 627.5$ kcal/mol $= 4.360 \times 10^{-18}$ J
    \item Length unit (Bohr): $\bohr = 0.5292$ Å $= 5.292 \times 10^{-11}$ m
    \item Time unit: $\hbar/E_h = 2.419 \times 10^{-17}$ s $= 24.19$ as
    \item Velocity unit: $c/137.04$ (fine structure constant $\alpha^{-1}$)
\end{itemize}

\chapter{Numerical Methods Reference}

Key algorithms for quantum simulations:

\section*{Eigenvalue Solvers}
\begin{itemize}
    \item Dense matrices: LAPACK (\texttt{dsyev}, \texttt{zheev}) $\mathcal{O}(N^3)$
    \item Sparse matrices: Lanczos, Arnoldi, Davidson $\mathcal{O}(kN^2)$, $k \ll N$
\end{itemize}

\section*{Integral Evaluation}
\begin{itemize}
    \item Gaussian quadrature: high-order accuracy with few points
    \item Lebedev grids: spherical integration for DFT
    \item Adaptive mesh refinement: automatic grid optimization
\end{itemize}

\section*{Optimization Algorithms}
\begin{itemize}
    \item BFGS: quasi-Newton method for geometry optimization
    \item Conjugate gradient: for large systems
    \item DIIS (Direct Inversion in Iterative Subspace): SCF acceleration
\end{itemize}

% ============================================
% END DOCUMENT
% ============================================
\end{document}