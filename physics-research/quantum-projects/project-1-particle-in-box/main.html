<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Computational Quantum Mechanics</title>
    <!-- MathJax 3 渲染LaTeX公式（核心，必须保留） -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- 代码高亮 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/lib/languages/python.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Times New Roman', Times, serif;
        }
        body {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem 3rem;
            line-height: 1.8;
            color: #222;
            background-color: #f8f9fa;
        }
        h1 {
            text-align: center;
            font-size: 2.2rem;
            margin-bottom: 0.5rem;
            color: #000;
        }
        h2 {
            font-size: 1.8rem;
            margin: 2rem 0 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #333;
        }
        h3 {
            font-size: 1.4rem;
            margin: 1.5rem 0 0.8rem;
        }
        h4 {
            font-size: 1.2rem;
            margin: 1.2rem 0 0.6rem;
        }
        .subtitle {
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 2rem;
            color: #555;
        }
        /* 目录样式 */
        .toc {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: #e9ecef;
            border-radius: 8px;
        }
        .toc h2 {
            font-size: 1.5rem;
            border: none;
            margin: 0 0 1rem 0;
            padding: 0;
        }
        .toc ul {
            list-style: none;
            padding-left: 1rem;
        }
        .toc li {
            margin: 0.5rem 0;
        }
        .toc a {
            color: #007bff;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        /* 公式容器：核心修正 - 确保公式单独成行 */
        .equation {
            position: relative; /* 为编号定位提供基准 */
            margin: 1.5rem 0;   /* 公式上下间距 */
            padding-right: 6rem;/* 为编号预留空间 */
        }
        /* 公式样式：居中 */
        mjx-container {
            display: block !important;
            margin: 0 auto !important;
        }
        /* 公式编号：核心修正 - 精准定位 */
        .eq-number {
            position: absolute;  /* 绝对定位 */
            right: 0;            /* 靠右侧对齐 */
            top: 50%;            /* 垂直居中 */
            transform: translateY(-50%); /* 精准居中 */
            color: #555;
            margin: 0;           /* 清除默认margin */
        }
        /* 代码块样式 */
        pre {
            background-color: #212529;
            color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
        }
        /* 表格样式 */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1.5rem 0;
            text-align: center;
        }
        th, td {
            border: 1px solid #333;
            padding: 0.8rem;
        }
        th {
            background-color: #e9ecef;
            font-weight: bold;
        }
        /* 插图占位样式 */
        .figure-placeholder {
            border: 2px dashed #6c757d;
            padding: 3rem;
            text-align: center;
            margin: 1.5rem 0;
            border-radius: 8px;
            color: #6c757d;
        }
        .figure-caption {
            text-align: center;
            font-size: 0.95rem;
            margin: 0.5rem 0 1.5rem;
            font-style: italic;
        }
        /* 列表样式 */
        ul, ol {
            padding-left: 2rem;
            margin: 1rem 0;
        }
        /* 附录样式 */
        .appendix {
            margin-top: 3rem;
            border-top: 3px solid #333;
            padding-top: 2rem;
        }
        /* 锚点平滑滚动 */
        html {
            scroll-behavior: smooth;
        }
    </style>
</head>
<body>
    <!-- 标题 -->
    <h1>Advanced Computational Quantum Mechanics</h1>
    <div class="subtitle">Mathematical Foundations and Numerical Implementation<br>A Comprehensive Technical Reference<br>February 5, 2026</div>

    <!-- 目录 -->
    <div class="toc" id="toc">
        <h2>Contents</h2>
        <ul>
            <li><a href="#ch1">1 Quantum Mechanics and Computational Quantum Mechanics</a>
                <ul>
                    <li><a href="#ch1-1">1.1 Mathematical Foundations</a></li>
                    <li><a href="#ch1-2">1.2 Analytical Solutions: Hydrogen Atom</a></li>
                    <li><a href="#ch1-3">1.3 The Many-Body Problem</a></li>
                    <li><a href="#ch1-4">1.4 Born-Oppenheimer Approximation</a></li>
                    <li><a href="#ch1-5">1.5 Density Functional Theory</a></li>
                </ul>
            </li>
            <li><a href="#ch2">2 Programming and Algorithmic Analysis</a>
                <ul>
                    <li><a href="#ch2-1">2.1 Computational Complexity</a></li>
                    <li><a href="#ch2-2">2.2 Python Scientific Computing Stack</a></li>
                    <li><a href="#ch2-3">2.3 Parallel Computing</a></li>
                </ul>
            </li>
            <li><a href="#ch3">3 Computational Quantum Dynamics</a>
                <ul>
                    <li><a href="#ch3-1">3.1 Time-Dependent Schrödinger Equation</a></li>
                    <li><a href="#ch3-2">3.2 Split-Operator Method</a></li>
                    <li><a href="#ch3-3">3.3 Runge-Kutta Methods</a></li>
                    <li><a href="#ch3-4">3.4 Chebyshev Polynomial Expansion</a></li>
                </ul>
            </li>
            <li><a href="#ch4">4 Implementation: Detailed Code Examples</a>
                <ul>
                    <li><a href="#ch4-1">4.1 Time-Independent Schrödinger Equation Solver</a></li>
                    <li><a href="#ch4-2">4.2 Time-Dependent Schrödinger Equation: Split-Operator Method</a></li>
                    <li><a href="#ch4-3">4.3 Hartree-Fock Self-Consistent Field Method</a></li>
                </ul>
            </li>
            <li><a href="#ch5">5 Advanced Topics and Extensions</a>
                <ul>
                    <li><a href="#ch5-1">5.1 Basis Set Selection and Convergence</a></li>
                    <li><a href="#ch5-2">5.2 Post-Hartree-Fock Methods</a></li>
                    <li><a href="#ch5-3">5.3 Density Functional Theory in Practice</a></li>
                    <li><a href="#ch5-4">5.4 Future Directions</a></li>
                    <li><a href="#ch5-5">5.5 Method Comparison Summary</a></li>
                </ul>
            </li>
            <li><a href="#appA">A Useful Constants and Conversion Factors</a></li>
            <li><a href="#appB">B Numerical Methods Reference</a></li>
        </ul>
    </div>

    <!-- 第1章 量子力学与计算量子力学 -->
    <h2 id="ch1">1 Quantum Mechanics and Computational Quantum Mechanics</h2>
    <h3 id="ch1-1">1.1 Mathematical Foundations</h3>
    <h4>1.1.1 Hilbert Space and State Vectors</h4>
    <p>The state of a quantum system is represented by a vector \(|\psi\rangle\) in a complex Hilbert space \(H\). For a single particle in three dimensions, the wavefunction \(\psi(r, t) \in L^{2}(\mathbb{R}^{3})\) must belong to the space of square-integrable functions, satisfying the normalization condition:</p>
    <div class="equation">
        \[
        \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} \int_{-\infty}^{\infty}|\psi(r, t)|^{2} d^{3} r=1
        \]
        <p class="eq-number">(1.1)</p>
    </div>
    <p>The inner product in this space is defined as:</p>
    <div class="equation">
        \[
        \langle\phi | \psi\rangle=\int \phi^{*}(r, t) \psi(r, t) d^{3} r
        \]
        <p class="eq-number">(1.2)</p>
    </div>
    <p>where \(\phi^{*}\) denotes the complex conjugate. This forms a complete inner product space with norm \(\|\psi\|=\sqrt{\langle\psi | \psi\rangle}\).</p>

    <h4>1.1.2 Fundamental Operators</h4>
    <p>Physical observables correspond to Hermitian operators on \(H\). The key operators are:</p>
    <ul>
        <li>Position operator: \(\hat{r} \psi(r)=r \psi(r)\)</li>
        <li>Momentum operator: \(\hat{p}=-i \hbar \nabla\)</li>
        <li>Hamiltonian operator: \(\hat{H}=\hat{T}+\hat{V}=-\frac{\hbar^{2}}{2 m} \nabla^{2}+V(r)\)</li>
    </ul>
    <p>The Hermiticity condition \(\hat{A}^{\dagger}=\hat{A}\) ensures real eigenvalues, corresponding to measurable physical quantities.</p>

    <h4>1.1.3 Time-Independent Schrödinger Equation</h4>
    <p>For stationary states, the time-independent Schrödinger equation (TISE) determines the energy eigenvalues and eigenfunctions:</p>
    <div class="equation">
        \[
        \hat{H} \phi(r)=E \phi(r)
        \]
        <p class="eq-number">(1.3)</p>
    </div>
    <p>Explicitly for a single particle:</p>
    <div class="equation">
        \[
        \left[-\frac{\hbar^{2}}{2 m} \nabla^{2}+V(r)\right] \phi(r)=E \phi(r)
        \]
    </div>

    <h3 id="ch1-2">1.2 Analytical Solutions: Hydrogen Atom</h3>
    <p>The hydrogen atom provides one of the few exactly solvable quantum systems. In spherical coordinates \((r, \theta, \phi)\), the TISE becomes:</p>
    <div class="equation">
        \[
        \left[-\frac{\hbar^{2}}{2 \mu}\left(\frac{1}{r^{2}} \frac{\partial}{\partial r}\left(r^{2} \frac{\partial}{\partial r}\right)+\frac{\hat{L}^{2}}{\hbar^{2} r^{2}}\right)-\frac{e^{2}}{4 \pi \epsilon_{0} r}\right] \psi=E \psi
        \]
    </div>
    <p>where \(\mu=\frac{m_{e} m_{p}}{m_{e}+m_{p}} \approx m_{e}\) is the reduced mass. Separation of variables \(\psi(r, \theta, \phi)=R(r) Y_{\ell}^{m}(\theta, \phi)\) yields the radial equation:</p>
    <div class="equation">
        \[
        \left[-\frac{\hbar^{2}}{2 \mu r^{2}} \frac{d}{d r}\left(r^{2} \frac{d R}{d r}\right)+\frac{\hbar^{2} \ell(\ell+1)}{2 \mu r^{2}}-\frac{e^{2}}{4 \pi \epsilon_{0} r}\right] R(r)=E R(r)
        \]
    </div>
    <p>Energy eigenvalues:</p>
    <div class="equation">
        \[
        E_{n}=-\frac{\mu e^{4}}{32 \pi^{2} \epsilon_{0}^{2} \hbar^{2} n^{2}} \approx-\frac{13.6 \text{ eV}}{n^{2}}, n=1,2,3, \dots
        \]
        <p class="eq-number">(1.7)</p>
    </div>
    <p>Bohr radius:</p>
    <div class="equation">
        \[
        a_{0}=\frac{4 \pi \epsilon_{0} \hbar^{2}}{\mu e^{2}} \approx 0.529 \mathring{\text{A}}
        \]
        <p class="eq-number">(1.8)</p>
    </div>
    <p>First three radial wavefunctions:</p>
    <div class="equation">
        \[
        R_{10}(r)=2\left(\frac{Z}{a_{0}}\right)^{3 / 2} \exp \left(-\frac{Z r}{a_{0}}\right)
        \]
        <p class="eq-number">(1.9)</p>
    </div>
    <div class="equation">
        \[
        R_{20}(r)=\frac{1}{2 \sqrt{2}}\left(\frac{Z}{a_{0}}\right)^{3 / 2}\left(2-\frac{Z r}{a_{0}}\right) \exp \left(-\frac{Z r}{2 a_{0}}\right)
        \]
        <p class="eq-number">(1.10)</p>
    </div>
    <div class="equation">
        \[
        R_{21}(r)=\frac{1}{2 \sqrt{6}}\left(\frac{Z}{a_{0}}\right)^{3 / 2} \frac{Z r}{a_{0}} \exp \left(-\frac{Z r}{2 a_{0}}\right)
        \]
        <p class="eq-number">(1.11)</p>
    </div>

    <!-- 图1.1 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 1.1: Radial probability distributions \(4 \pi r^{2}|R_{n \ell}(r)|^{2}\) for \(n=1,2,3\) orbitals of hydrogen, showing nodes and peak positions
    </div>
    <p class="figure-caption">Figure 1.1: Hydrogen atom radial probability distributions</p>

    <h3 id="ch1-3">1.3 The Many-Body Problem</h3>
    <p>For \(N\) electrons interacting with \(M\) nuclei, the full non-relativistic Hamiltonian is:</p>
    <div class="equation">
        \[
        \hat{H}=\hat{T}_{e}+\hat{T}_{n}+\hat{V}_{e n}+\hat{V}_{e e}+\hat{V}_{n n}
        \]
        <p class="eq-number">(1.12)</p>
    </div>
    <p>where:</p>
    <div class="equation">
        \[
        \hat{T}_{e}=-\sum_{i=1}^{N} \frac{\hbar^{2}}{2 m_{e}} \nabla_{i}^{2} \quad (\text{electron kinetic})
        \]
        <p class="eq-number">(1.13)</p>
    </div>
    <div class="equation">
        \[
        \hat{T}_{n}=-\sum_{a=1}^{M} \frac{\hbar^{2}}{2 M_{a}} \nabla_{a}^{2} \quad (\text{nuclear kinetic})
        \]
        <p class="eq-number">(1.14)</p>
    </div>
    <div class="equation">
        \[
        \hat{V}_{e n}=-\sum_{i=1}^{N} \sum_{a=1}^{M} \frac{Z_{a} e^{2}}{4 \pi \epsilon_{0}\left|r_{i}-R_{a}\right|} \quad (\text{electron-nuclear})
        \]
        <p class="eq-number">(1.15)</p>
    </div>
    <div class="equation">
        \[
        \hat{V}_{e e}=\sum_{i<j} \frac{e^{2}}{4 \pi \epsilon_{0}\left|r_{i}-r_{j}\right|} \quad (\text{electron-electron})
        \]
        <p class="eq-number">(1.16)</p>
    </div>
    <div class="equation">
        \[
        \hat{V}_{n n}=\sum_{a<b} \frac{Z_{a} Z_{b} e^{2}}{4 \pi \epsilon_{0}\left|R_{a}-R_{b}\right|} \quad (\text{nuclear-nuclear})
        \]
        <p class="eq-number">(1.17)</p>
    </div>
    <p>Computational scaling: The wavefunction \(\Psi(r_{1}, ..., r_{N}, R_{1}, ..., R_{M})\) depends on \(3(N+M)\) coordinates. Discretizing each dimension with \(M\) grid points gives \(M^{3(N+M)}\) total points:</p>
    <ul>
        <li>\(H_{2}\) (2 electrons, 2 nuclei): \(M^{12}\) points</li>
        <li>\(H_{2}O\) (10 electrons, 3 nuclei): \(M^{39}\) points</li>
        <li>\(C_{6}H_{6}\) (42 electrons, 12 nuclei): \(M^{162}\) points</li>
    </ul>
    <p>For \(M=100\), \(H_{2}O\) requires \(10^{39}\) points - utterly intractable.</p>

    <!-- 图1.2 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 1.2: Log-log plot showing exponential growth of required grid points vs number of electrons for \(M=50,100,200\)
    </div>
    <p class="figure-caption">Figure 1.2: Exponential scaling of direct grid method</p>

    <h3 id="ch1-4">1.4 Born-Oppenheimer Approximation</h3>
    <p>Nuclear masses greatly exceed electron mass (\(m_{e} / M_{p} ≈1 / 1836\)), allowing separation:</p>
    <div class="equation">
        \[
        \Psi_{\text{total}}(r,R) \approx \psi _{e}(r;R)\chi _{n}(R)
        \]
        <p class="eq-number">(1.18)</p>
    </div>
    <p>The electronic Hamiltonian at fixed nuclear positions \(R\):</p>
    <div class="equation">
        \[
        \hat{H}_{e} \psi_{e}(r ; R)=E_{e}(R) \psi_{e}(r ; R)
        \]
        <p class="eq-number">(1.19)</p>
    </div>
    <p>where \(E_{e}(R)\) forms the potential energy surface for nuclear motion.<br>Error magnitude: \(~(m_{e} / M)^{1 / 4} ≈10^{-3}\), increasing near conical intersections.</p>

    <h3 id="ch1-5">1.5 Density Functional Theory</h3>
    <h4>1.5.1 Hohenberg-Kohn Theorems</h4>
    <p>Theorem 1 (Existence): The ground state energy is a unique functional of electron density:</p>
    <div class="equation">
        \[
        E_{0}=E\left[n_{0}(r)\right]=\int V_{\text{ext }}(r) n_{0}(r) d r+F\left[n_{0}(r)\right]
        \]
        <p class="eq-number">(1.20)</p>
    </div>
    <p>where \(F[n]=T[n]+V_{e e}[n]\) is a universal functional (independent of \(V_{\text{ext }}\)).</p>
    <p>Theorem 2 (Variational Principle): For any trial density \(\tilde{n}(r)\) with \(\int \tilde{n}(r) d r=N\):</p>
    <div class="equation">
        \[
        E[\tilde{n}] \geq E\left[n_{0}\right], \text{ with equality iff } \tilde{n}=n_{0}
        \]
        <p class="eq-number">(1.21)</p>
    </div>

    <h4>1.5.2 Kohn-Sham Equations</h4>
    <p>Map the interacting system to a non-interacting one with the same density:</p>
    <div class="equation">
        \[
        \left[-\frac{\hbar^{2}}{2 m_{e}} \nabla^{2}+V_{\text{eff }}[n](r)\right] \phi_{i}(r)=\varepsilon_{i} \phi_{i}(r)
        \]
        <p class="eq-number">(1.22)</p>
    </div>
    <div class="equation">
        \[
        V_{\text{eff }}[n](r)=V_{\text{ext }}(r)+\int \frac{e^{2} n\left(r'\right)}{4 \pi \epsilon_{0}\left|r-r'\right|} d r'+V_{x c}[n](r)
        \]
        <p class="eq-number">(1.23)</p>
    </div>
    <div class="equation">
        \[
        n(r)=\sum_{i=1}^{N}\left|\phi_{i}(r)\right|^{2}
        \]
        <p class="eq-number">(1.24)</p>
    </div>
    <p>The exchange-correlation potential \(V_{x c}=\delta E_{x c} / \delta n(r)\) contains all many-body effects.<br>Common approximations:</p>
    <p>Local Density Approximation (LDA):</p>
    <div class="equation">
        \[
        E_{x c}^{\text{LDA}}[n]=\int n(r) \varepsilon_{x c}(n(r)) d r
        \]
        <p class="eq-number">(1.25)</p>
    </div>
    <p>Generalized Gradient Approximation (GGA) - PBE functional:</p>
    <div class="equation">
        \[
        E_{x c}^{\text{PBE}}[n]=\int n(r) \varepsilon_{x c}(n(r),|\nabla n(r)|) d r
        \]
        <p class="eq-number">(1.26)</p>
    </div>
    <p>Hybrid functionals (B3LYP):</p>
    <div class="equation">
        \[
        E_{xc}^{\text{B3LYP}}=0.8E_{x}^{\text{LDA}}+0.2E_{x}^{\text{HF}}+0.72\Delta E_{x}^{\text{B88}}+0.19E_{c}^{\text{VWN}}+0.81E_{c}^{\text{LYP}}
        \]
        <p class="eq-number">(1.27)</p>
    </div>
    <p>Computational scaling: DFT-KS scales as \(O(N^{3})\) with system size \(N\) (matrix diagonalization), compared to \(O(N!)\) for exact methods.</p>

    <!-- 图1.3 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 1.3: Computational cost comparison (log-scale) for Full CI, CCSD, MP2, DFT, Tight-Binding vs system size \(N\)
    </div>
    <p class="figure-caption">Figure 1.3: Scaling of quantum mechanical methods</p>

    <!-- 第2章 编程与算法分析 -->
    <h2 id="ch2">2 Programming and Algorithmic Analysis</h2>
    <h3 id="ch2-1">2.1 Computational Complexity</h3>
    <p>Key computational bottlenecks in quantum simulations:</p>
    <ul>
        <li>Matrix diagonalization: \(O(N^{3})\) for dense \(N ×N\) matrices</li>
        <li>Two-electron integrals: \(O(N^{4})\) for \(N\) basis functions</li>
        <li>SCF iterations: 10–100 cycles typically required</li>
        <li>Sparse linear solvers: \(O(N^{1.5})\) for sparse Hamiltonians</li>
    </ul>

    <h3 id="ch2-2">2.2 Python Scientific Computing Stack</h3>
    <h4>2.2.1 NumPy - Numerical Linear Algebra</h4>
    <p>Core functions:</p>
    <ul>
        <li>np.linalg.eigh(A): Hermitian eigendecomposition, \(O(N^{3})\)</li>
        <li>np.einsum(’ij,jk->ik’, A, B): Efficient tensor contractions</li>
        <li>np.linalg.lstsq(A, b): Least-squares solutions</li>
        <li>np.fft: Fast Fourier Transform, \(O(N log N)\)</li>
    </ul>

    <h4>2.2.2 SciPy - Advanced Algorithms</h4>
    <ul>
        <li>scipy.sparse: COO, CSR, CSC formats for sparse matrices</li>
        <li>scipy.sparse.linalg.eigs(): Iterative eigensolvers (Lanczos/Arnoldi)</li>
        <li>scipy.integrate.odeint(): Stiff ODE solver (for TDSE)</li>
        <li>scipy.optimize: BFGS, conjugate gradient for geometry optimization</li>
    </ul>

    <h4>2.2.3 PySCF - Production Quantum Chemistry</h4>
    <ul>
        <li>Hartree-Fock: pyscf.scf.RHF(), pyscf.scf.UHF()</li>
        <li>Post-HF: MP2, CCSD, CCSD(T), Full CI</li>
        <li>DFT: LDA, PBE, B3LYP, ωB97X-D functionals</li>
        <li>TDDFT: Linear response excited states</li>
    </ul>

    <h3 id="ch2-3">2.3 Parallel Computing</h3>
    <h4>2.3.1 Shared Memory Parallelism (OpenMP)</h4>
    <p>BLAS libraries (MKL, OpenBLAS) automatically parallelize matrix operations. Speedup:</p>
    <div class="equation">
        \[
        S(p)=\frac{T(1)}{T(p)} \approx \frac{p}{1+(p-1) f}
        \]
    </div>
    <p>where \(f\) is the serial fraction (Amdahl’s law).</p>

    <h4>2.3.2 Distributed Memory (MPI)</h4>
    <p>For multi-node clusters, use mpi4py for Python:</p>
    <ul>
        <li>Distribute Hamiltonian matrix blocks across processes</li>
        <li>Local computation of matrix elements</li>
        <li>MPI_Allgather for global communication</li>
    </ul>

    <h4>2.3.3 GPU Acceleration</h4>
    <p>Modern GPUs provide 10–100× speedup for dense linear algebra:</p>
    <ul>
        <li>CuPy: NumPy API for NVIDIA CUDA</li>
        <li>TensorFlow/PyTorch: Automatic differentiation</li>
        <li>Typical speedup: 20–50× for \(N>1000\) matrix operations</li>
    </ul>

    <!-- 图2.1 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 2.1: Benchmark plot showing CPU vs GPU vs Multi-CPU (MPI) execution time for matrix diagonalization, \(N=100\) to 10000
    </div>
    <p class="figure-caption">Figure 2.1: Performance comparison for matrix operations</p>

    <!-- 第3章 计算量子动力学 -->
    <h2 id="ch3">3 Computational Quantum Dynamics</h2>
    <h3 id="ch3-1">3.1 Time-Dependent Schrödinger Equation</h3>
    <p>The TDSE governs quantum time evolution:</p>
    <div class="equation">
        \[
        i \hbar \frac{\partial }{\partial t}|\psi (t)\rangle =\hat{H}(t)|\psi (t)\rangle
        \]
        <p class="eq-number">(3.1)</p>
    </div>
    <p>Formal solution (time-ordered exponential):</p>
    <div class="equation">
        \[
        |\psi(t)\rangle=\mathcal{T} \exp \left(-\frac{i}{\hbar} \int_{t_{0}}^{t} \hat{H}\left(t'\right) d t'\right)|\psi\left(t_{0}\right)\rangle
        \]
        <p class="eq-number">(3.2)</p>
    </div>
    <p>For time-independent \(\hat{H}\):</p>
    <div class="equation">
        \[
        \hat{U}(t, t_{0})=\exp \left(-\frac{i \hat{H}\left(t-t_{0}\right)}{\hbar}\right)
        \]
        <p class="eq-number">(3.3)</p>
    </div>

    <h3 id="ch3-2">3.2 Split-Operator Method</h3>
    <p>For \(\hat{H}=\hat{T}+\hat{V}\), use Trotter-Suzuki decomposition:</p>
    <div class="equation">
        \[
        \exp \left( -\frac {i\hat {H}\Delta t}{\hbar }\right) =exp \left( -\frac {i\hat {T}\Delta t}{2\hbar }\right) \exp \left( -\frac {i\hat {V}\Delta t}{\hbar}\right) \exp \left( -\frac {i\hat {T}\Delta t}{2\hbar }\right) +\mathcal {O}\left( \Delta t^{3}\right)
        \]
        <p class="eq-number">(3.4)</p>
    </div>
    <p>Algorithm:</p>
    <ol>
        <li>\(\psi(p)=\text{FFT}[\psi(x)]\)</li>
        <li>\(\tilde{\psi}'(p)=\exp \left(-\frac{i p^{2} \Delta t}{4 m \hbar}\right) \tilde{\psi}(p)\)</li>
        <li>\(\psi'(x)=\text{IFFT}\left[\tilde{\psi}'(p)\right]\)</li>
        <li>\(\psi''(x)=\exp \left(-\frac{i V(x) \Delta t}{\hbar}\right) \psi'(x)\)</li>
        <li>Repeat steps 1–2 once more</li>
    </ol>
    <p>Properties:</p>
    <ul>
        <li>Unitary (norm-preserving): \(\|\psi(t)\|=\|\psi(0)\|\)</li>
        <li>Computational cost: \(O(N log N)\) per timestep</li>
        <li>Error: \(O(\Delta t^{3})\) local, \(O(\Delta t^{2})\) global</li>
    </ul>

    <h3 id="ch3-3">3.3 Runge-Kutta Methods</h3>
    <h4>3.3.1 Fourth-Order Runge-Kutta (RK4)</h4>
    <p>Rewrite TDSE as: \(\frac{d \psi}{d t}=f(\psi, t)=-\frac{i \hat{H}(t) \psi}{\hbar}\)</p>
    <div class="equation">
        \[
        k_{1}=\Delta t\, f(\psi _{n}, t_{n})
        \]
        <p class="eq-number">(3.5)</p>
    </div>
    <div class="equation">
        \[
        k_{2}=\Delta t\, f(\psi _{n}+k_{1}/2,t_{n}+\Delta t/2)
        \]
        <p class="eq-number">(3.6)</p>
    </div>
    <div class="equation">
        \[
        k_{3}=\Delta t\, f(\psi _{n}+k_{2}/2,t_{n}+\Delta t/2)
        \]
        <p class="eq-number">(3.7)</p>
    </div>
    <div class="equation">
        \[
        k_{4}=\Delta t\, f(\psi _{n}+k_{3},t_{n}+\Delta t)
        \]
        <p class="eq-number">(3.8)</p>
    </div>
    <div class="equation">
        \[
        \psi_{n+1}=\psi_{n}+\frac{1}{6}\left(k_{1}+2 k_{2}+2 k_{3}+k_{4}\right)
        \]
        <p class="eq-number">(3.9)</p>
    </div>
    <p>Accuracy: \(O(\Delta t^{4})\) global error<br>Limitation: Non-unitary - norm can drift, requires renormalization.</p>

    <h3 id="ch3-4">3.4 Chebyshev Polynomial Expansion</h3>
    <div class="equation">
        \[
        \exp \left(-\frac{i \hat{H} t}{\hbar}\right)=\sum_{n=0}^{\infty} a_{n}(t) T_{n}\left(\frac{\hat{H}-c}{\Delta}\right)
        \]
        <p class="eq-number">(3.10)</p>
    </div>
    <p>Expand propagator using Chebyshev polynomials \(T_{n}(x)\) where \(c=(E_{\text{max }}+E_{\text{min }}) / 2\), \(\Delta=(E_{\text{max }}-E_{\text{min }}) / 2\) rescale spectrum to \([-1, 1]\).</p>
    <p>Coefficients:</p>
    <div class="equation">
        \[
        a_{n}(t)=(2-\delta _{n0})(-i)^{n}\exp \left( -\frac {i c t}{\hbar }\right) J_{n}\left( \frac {\Delta t}{\hbar }\right)
        \]
        <p class="eq-number">(3.11)</p>
    </div>
    <p>where \(J_{n}\) is the Bessel function of the first kind.<br>Recurrence: \(T_{0}(x)=1\), \(T_{1}(x)=x\), \(T_{n+1}(x)=2 x T_{n}(x)-T_{n-1}(x)\)</p>
    <p>Advantages:</p>
    <ul>
        <li>Spectral accuracy: exponential convergence with order \(n\)</li>
        <li>Unitary to machine precision</li>
        <li>Only requires \(\hat{H}|\psi\rangle\) (no diagonalization)</li>
    </ul>

    <!-- 图3.1 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 3.1: Norm conservation comparison: Split-Operator, RK4, Chebyshev over 1000 steps showing RK4 drift
    </div>
    <p class="figure-caption">Figure 3.1: Comparison of norm conservation for different propagators</p>

    <!-- 第4章 实现：详细代码示例 -->
    <h2 id="ch4">4 Implementation: Detailed Code Examples</h2>
    <h3 id="ch4-1">4.1 Time-Independent Schrödinger Equation Solver</h3>
    <h4>4.1.1 Problem: 1D Quantum Harmonic Oscillator</h4>
    <p>TISE in dimensionless units (\(\hbar=m=\omega=1\)):</p>
    <div class="equation">
        \[
        \left[-\frac{1}{2} \frac{d^{2}}{ d x^{2}}+\frac{x^{2}}{2}\right] \phi(x)=E \phi(x)
        \]
        <p class="eq-number">(4.1)</p>
    </div>
    <p>Analytical: \(E_{n}=n+1 / 2\), \(\phi_{n}(x)=\frac{1}{\sqrt{2^{n} n ! \sqrt{\pi}}} H_{n}(x) e^{-x^{2} / 2}\)</p>

    <h4>4.1.2 Finite Difference Discretization</h4>
    <p>Grid: \(x_{j}=-L+j \Delta x\), \(j=0,1, ..., N-1\), \(\Delta x=2 L /(N-1)\)<br>Central difference (\(O(\Delta x^{2})\)):</p>
    <div class="equation">
        \[
        \left.\frac{d^{2} \phi}{d x^{2}}\right|_{j} \approx \frac{\phi_{j+1}-2 \phi_{j}+\phi_{j-1}}{\Delta x^{2}}
        \]
        <p class="eq-number">(4.2)</p>
    </div>
    <p>Hamiltonian matrix (tridiagonal):</p>
    <div class="equation">
        \[
        H_{i j}=\delta_{i j}\left(\frac{1}{\Delta x^{2}}+\frac{x_{i}^{2}}{2}\right)-\frac{\delta_{i, j \pm 1}}{2 \Delta x^{2}}
        \]
        <p class="eq-number">(4.3)</p>
    </div>

    <h4>4.1.3 Complete Python Implementation</h4>
    <pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import eigh

# 1D Harmonic Oscillator TISE Solver
def solve_harmonic_oscillator_1d(N=500, L=10, n_states=5):
    """
    Solve 1D harmonic oscillator using finite difference method

    Parameters:
        N : int
            Number of grid points
        L : float
            Half-length of domain [-L, L]
        n_states : int
            Number of lowest eigenstates to compute

    Returns:
        x : ndarray
            Spatial grid
        energies : ndarray
            Energy eigenvalues
        wavefunctions : ndarray
            Normalized eigenfunctions
    """
    # Create spatial grid
    x = np.linspace(-L, L, N)
    dx = x[1] - x[0]

    # Construct Hamiltonian matrix (tridiagonal)
    # Kinetic energy matrix
    T_diag = np.ones(N) / dx**2
    T_offdiag = -np.ones(N-1) / (2*dx**2)

    # Potential energy matrix
    V = 0.5 * x**2

    # Full Hamiltonian
    H = (np.diag(T_diag + V) +
         np.diag(T_offdiag, k=1) +
         np.diag(T_offdiag, k=-1))

    # Solve eigenvalue problem Hϕ = Eϕ
    energies, wavefunctions = eigh(H)

    # Extract requested states
    energies = energies[:n_states]
    wavefunctions = wavefunctions[:, :n_states]

    # Normalize wavefunctions
    for i in range(n_states):
        norm = np.sqrt(np.trapz(np.abs(wavefunctions[:, i])**2, x))
        wavefunctions[:, i] /= norm

        # Phase convention: positive at center
        center_idx = N // 2
        if wavefunctions[center_idx, i] < 0:
            wavefunctions[:, i] *= -1

    return x, energies, wavefunctions

def analytical_harmonic_oscillator(x, n):
    """Analytical solution: ϕn(x) = 1/√(2^n n!√π) Hn(x)e^(-x²/2)"""
    from scipy.special import hermite, factorial
    N_n = 1.0 / np.sqrt(2**n * factorial(n) * np.sqrt(np.pi))
    H_n = hermite(n)
    phi_n = N_n * H_n(x) * np.exp(-x**2 / 2)
    return phi_n

# ============================================
# Main execution
# ============================================
if __name__ == "__main__":
    print("="*60)
    print("1D Harmonic Oscillator: Numerical vs Analytical")
    print("="*60)

    # Solve numerically
    x, E_num, psi_num = solve_harmonic_oscillator_1d(N=500, L=10, n_states=5)

    # Analytical energies
    E_analytical = np.array([n + 0.5 for n in range(5)])

    # Print comparison
    print("\nEnergy Eigenvalues:")
    print("-" * 70)
    print(f"{'n':>3} | {'E_numerical':>15} | {'E_analytical':>15} | {'Rel. Error':>12}")
    print("-" * 70)
    for n in range(5):
        rel_error = np.abs(E_num[n] - E_analytical[n]) / E_analytical[n]
        print(f"{n:3d} | {E_num[n]:15.10f} | {E_analytical[n]:15.10f} | {rel_error:12.2e}")
</code></pre>

    <h4>4.1.4 Convergence Analysis and Error Scaling</h4>
    <p>The finite difference approximation introduces truncation error:</p>
    <div class="equation">
        \[
        \varepsilon_{\text{trunc}}=\left|E_{\text{numerical }}-E_{\text{exact }}\right|=C × \Delta x^{2}+\mathcal{O}\left(\Delta x^{4}\right)
        \]
        <p class="eq-number">(4.4)</p>
    </div>
    <p>Empirical fitting shows \(C ≈0.01\) for the ground state. Doubling grid resolution (\(N \to 2N\), \(\Delta x \to \Delta x / 2\)) reduces error by factor of 4, confirming second-order convergence.<br>For \(n\)-th excited state, error magnitude increases as:</p>
    <div class="equation">
        \[
        \varepsilon_{n} \approx C_{n} × \Delta x^{2}, \text{ where } C_{n} \approx C_{0} \times(n+1)^{2}
        \]
        <p class="eq-number">(4.5)</p>
    </div>
    <p>This reflects the increasing curvature of higher energy wavefunctions, requiring finer grids for accurate resolution.</p>

    <!-- 图4.1、4.2 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 4.1: Plot showing numerical vs analytical wavefunctions \(\phi_{0}, \phi_{1}, \phi_{2}\) overlaid
    </div>
    <p class="figure-caption">Figure 4.1: Comparison of numerical and analytical solutions</p>
    <div class="figure-placeholder">
        INSERT FIGURE 4.2: Log-log plot of energy error vs grid spacing \(\Delta x\), demonstrating \(O(\Delta x^{2})\) convergence
    </div>
    <p class="figure-caption">Figure 4.2: Convergence analysis of finite difference method</p>

    <h3 id="ch4-2">4.2 Time-Dependent Schrödinger Equation: Split-Operator Method</h3>
    <h4>4.2.1 Problem: Gaussian Wave Packet in Harmonic Potential</h4>
    <p>Initial state (Gaussian wave packet):</p>
    <div class="equation">
        \[
        \psi(x, 0)=\left(2 \pi \sigma^{2}\right)^{-1 / 4} \exp \left(-\frac{\left(x-x_{0}\right)^{2}}{4 \sigma^{2}}\right) \exp \left(\frac{i p_{0} x}{\hbar}\right)
        \]
        <p class="eq-number">(4.6)</p>
    </div>
    <p>Time evolution under \(V(x)=x^{2} / 2\) (dimensionless units).<br>Physical interpretation: Wave packet oscillates in harmonic potential with angular frequency \(\omega=1\).</p>

    <h4>4.2.2 Split-Operator Algorithm Implementation</h4>
    <pre><code class="python">import numpy as np

def split_operator_propagator(psi, V, dt, dx):
    """
    Single time step using split-operator method
    exp −iˆH∆t/ℏ ≈ exp −iˆT∆t/2ℏ exp −iˆV∆t/ℏ exp −iˆT∆t/2ℏ
    """
    N = len(psi)
    k = 2 * np.pi * np.fft.fftfreq(N, dx)

    # Kinetic energy in momentum space
    T_k = 0.5 * k**2

    # Step 1: Half-step kinetic propagation
    psi_tilde = np.fft.fft(psi)
    psi_tilde *= np.exp(-1j * T_k * dt / 2)

    # Step 2: Transform to position space
    psi = np.fft.ifft(psi_tilde)

    # Step 3: Full-step potential propagation
    psi *= np.exp(-1j * V * dt)

    # Step 4: Half-step kinetic (repeat)
    psi_tilde = np.fft.fft(psi)
    psi_tilde *= np.exp(-1j * T_k * dt / 2)
    psi = np.fft.ifft(psi_tilde)

    return psi

def simulate_wave_packet(N=1024, L=20, T_final=10, dt=0.01, x0=0, p0=2, sigma=1):
    """Simulate Gaussian wave packet in harmonic oscillator"""
    x = np.linspace(-L, L, N)
    dx = x[1] - x[0]
    V = 0.5 * x**2

    # Initial Gaussian wave packet
    norm = (2 * np.pi * sigma**2)**(-0.25)
    psi = norm * np.exp(-(x - x0)**2 / (4 * sigma**2) + 1j * p0 * x)
    psi /= np.sqrt(np.trapz(np.abs(psi)**2, x))

    # Time evolution
    n_steps = int(T_final / dt)
    psi_t = [psi.copy()]
    times = [0]

    for step in range(1, n_steps + 1):
        psi = split_operator_propagator(psi, V, dt, dx)
        if step % (n_steps // 100) == 0:
            psi_t.append(psi.copy())
            times.append(step * dt)

    return x, psi_t, np.array(times)
</code></pre>

    <!-- 图4.3、4.4 占位 -->
    <div class="figure-placeholder">
        INSERT FIGURE 4.3: Animation frames showing \(|\psi(x, t)|^{2}\) evolution at \(t=0, \pi/2, \pi, 3\pi/2, 2\pi\)
    </div>
    <p class="figure-caption">Figure 4.3: Gaussian wave packet evolution in harmonic potential</p>
    <div class="figure-placeholder">
        INSERT FIGURE 4.4: Expectation value \(\langle x(t) \rangle\) vs time, showing harmonic oscillation with \(\omega=1\)
    </div>
    <p class="figure-caption">Figure 4.4: Expectation value of position over time</p>
</body>
</html>